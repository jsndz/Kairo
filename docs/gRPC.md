Lets Start with basics of rpc

RPC is a way to call a function a in another server
There are 2 main components:
client and server

Before going into writing the client we will look into the proto file which is used to generate pkg.

```go
//ai.proto
syntax = "proto3";

package ai;

option go_package = "github.com/jsndz/kairo-proto/ai;aipb";


service AIService {
	rpc Summarize (SummarizeRequest) returns (stream SummarizeResponse);
	rpc Rewrite (RewriteRequest) returns (stream RewriteResponse);
}


message SummarizeRequest {
	string doc_id = 1;
	string user_id = 2;
}

message SummarizeResponse {
	string summary = 1;
	bool done = 2;
}


message RewriteRequest {
	string doc_id = 1;
	string user_id = 2;
	int64 from =3;
	int64 to = 4;
	string prompt = 5;
}

message RewriteResponse {
	string text = 1;
	bool done = 2;
}
```

This is used to define the functions and input output structs for grpc.

To generate Go files from your .proto definitions (like ai.proto), you can use either protoc directly or the Buf CLI.
I am using buf.

```sh
go install github.com/bufbuild/buf/cmd/buf@latest
```

With buf you need two files in the main directory where you init your go project.

```yaml
# buf.yaml
version: v2
lint:
  use:
    - STANDARD
breaking:
  use:
    - FILE
```

```yaml
# buf.gen.yaml
version: v1
plugins:
  - name: go
    out: gen/go
    opt:
      - paths=source_relative
  - name: go-grpc
    out: gen/go
    opt:
      - paths=source_relative
```

after this run,

```sh
buf generate
```

there is simple way to create client with grpc:

```go
package clients

import (
	docpb "github.com/jsndz/kairo/gen/go/proto/doc"
	"google.golang.org/grpc"
)
//create client
func CreateClient(target string) *grpc.ClientConn {
	conn, err := grpc.NewClient(target, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("failed to connect to %s: %v", target, err)
	}
	return conn
}

func NewDocClient() (docpb.DocServiceClient,*grpc.ClientConn) {
	conn:= CreateClient("localhost:3002")
	docClient := docpb.NewDocServiceClient(conn)
	return docClient,conn
}



```

This creates a doc client.

Now we have client and lets initialize it in the main file.

```go
aiClient,aiconn := clients.NewAIClient()
defer aiconn.Close()

```

This will create a ai client and pass this to the handler.

the AiClient Provides Various methods to call. In the defination i mentioned about functions right the functions are accessible through AiClient

```go
type AIHandler struct{
	AiClient aipb.AIServiceClient
}

func (h *AIHandler) Summarize(ctx *gin.Context) {
	// run the function from AiClient
}
```

Now lets write the server part:

Lets register the server in port 3003

```go

type AiServer struct{
	h *handler.AiHandler
	aipb.UnimplementedAIServiceServer
	// implement all the functions except overridden ones
}

func NewAiServer(h *handler.AiHandler) (*AiServer) {
	return &AiServer{
		h:h,
	}
}

func main(){
	lis,err :=net.Listen("tcp",":3003")
	if err!=nil{
		log.Fatalf("Failed to listen: %v", err)
	}

	h := handler.NewAiHandler()
	aiserver := app.NewAiServer(h)
	grpcServer:= grpc.NewServer()

	aipb.RegisterAIServiceServer(grpcServer,aiserver) // registers aiservice with grpc service
	reflection.Register(grpcServer) // useful for debugging
	log.Println("AI gRPC server running on :3003")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("Failed to serve: %v", err)
    }
}
```

RegisterAIServiceServer this function is provided by the the aipb pkg which is generated by the command.
